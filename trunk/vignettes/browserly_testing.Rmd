---
title: "browser_ly_testing"
author: "Justin Finkle"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: 
      collapsed: false
      smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library(TxDb.Hsapiens.BioMart.igis3.0)
library(plotly)
library(org.Hs.eg.db)
library(chipVis)
```

```{r Load data, echo=FALSE}
# This is information specific to the project that has been preprocessed

# fi is the file_info object (a dataframe), that has file locations
fi <- readRDS("/gne/research/workspace/schepa/Carroll_Data/chip_file_info.Rds")

T47D = list(
  ER_ab = which(fi$source_name == "T47D_ER_Full_Media_3hr"),
  ER_ab_Pr_treat = which(fi$source_name == "T47D_ER_Progesterone_3hr"),
  ER_ab_R5020_treat = which(fi$source_name == "T47D_ER_R5020_3hr"),
  
  PR_ab  = which(fi$source_name == "T47D_PR_Full_Media_3hr"),
  PR_ab_Pr_treat = which(fi$source_name == "T47D_PR_Progesterone_3hr"),
  PR_ab_R5020_treat = which(fi$source_name == "T47D_PR_R5020_3hr"),
  
  p300_ab  = which(fi$source_name == "T47D_p300_Full_Media_3hr"),
  p300_ab_Pr_treat  = which(fi$source_name == "T47D_p300_Progesterone_3hr"),
  p300_ab_R5020_treat = which(fi$source_name == "T47D_p300_R5020_3hr")
  
)
```

# Plot single locus
## Input Data
A trackview requires three components to display properly.

1. The view range: a GRanges object describing the region to be displayed
2. Annotation data: a list containing annotation features that will be rendered
3. Coverage data: a GRanges object that contains the coverage to be displayed

### View Range
Browserly needs to know the range to plot. This is used to pull the correct annotation information. The function `get_view_range` makes the appropriate object for use with browserly. If passed an OrganismDbi object, `get_view_range` can also be used to get the range by gene symbol. Here we'll use the region for the gene GREB1, because it is a good responder to ER and PR.
```{r view_range}
view_range <- get_view_range(chr = 2, start=11482341, end=11642788)
view_range
```

The range can also be extended if desired. This is a particularly useful function when creating uniformly sized views around disparate regions. For example, the TSS of many genes can be made as 1bp GRanges and extended to be of equal length.

The range can be extended symmetrically on both sides
```{r extend range symmetric}
extend_grange(view_range, 50000)
```

or asymmetrically by passing a vector
```{r extend range asymmetric}
extend_grange(view_range, c(1000, 5000))
```

### Annotation data
We pre-load the annotation information from the TxDB into an easily searched list. This saves time when repeated calls are made to find the genomic ranges and features that are used in plotting coverage information. 
The variable `tx_data` contains several lists that a indexed by transcript
feature (e.g. intron, utr5). It also keeps track of the seqlevelstyle used
in the database.

```{r Load Annotation reference}
txdb <- TxDb.Hsapiens.BioMart.igis
tx_data <- load_tx_data(txdb)
print(names(tx_data))
```

**Note:** We also use the annotation helper function `match_tx_to_gene` to zip together OrgDB and TxDB objects by entrez id. This allows genes to be searched by gene symbol, which is often more human friendly.
``` {r match transcripts to genes}
symbol_table <- match_tx_to_gene(txdb, 'org.Hs.eg')
print(head(symbol_table))
```

### Coverage information.
Users are expected to provide their own data for plotting. Data should be provided as a GRanges object, where the metadata columns (mcols) contain the coverage values in each range.

The utility function `make_coverage_tracks` is provided
```{r Read Coverage Files, echo=FALSE}
# Specify coverage files
input <- fi[2, 'Sample.Control']
input_idx <- which(fi$Sample.Name==input)
idx <- sapply(T47D[c(1,2,4,5)], function(x){x[[1]]})
idx <- c(1, idx)
names(idx)[[1]] <- "ER_input"
shortened_names <- names(idx)

# Get scaling factor
sf <- get_scaling_factor(fi[idx,])/1000000
sf <- sf[2,]

# Get the coverage
cvg <- make_coverage_tracks(fi[idx, "File.bw"], 
                            target_range = view_range, 
                            sample_names = shortened_names, 
                            scaling_factors = sf)
print(head(cvg))
```


```{r Demo_stacking}
plot_single_locus(view_range, tx_data, cvg, stacking='squish', type="scatter")
```

```{r Demo_hm}
plot_single_locus(view_range, tx_data, cvg)
```

```{r Demo_line}
plot_single_locus(view_range, tx_data, cvg, type = "scatter")
```

# Plotting multiple genes for several conditions
```{r}
# set the gene list
genes <- c('RNF2', 'E2F1', 'GREB1', 'BAP1')

# Select the indices of the chip-seq experiments
# c_idx stands for conditions index

# Set how far upstream and downstream  you want to view from the TSS
extension <- 50000
conditions <- names(idx)
cvg_files <- fi[idx, "File.bw"]

centered_genes <- lapply(genes, function(gene){
  gene_data <- get_centered_gene_info(gene = gene,
                                      extension = extension,
                                      cvg_files = cvg_files,
                                      conditions = conditions,
                                      scaling_factor = sf,
                                      tx_data = tx_data,
                                      symbol_table = symbol_table)
  return(gene_data)
})
cvg_list <- GRangesList(lapply(centered_genes, function(x) {x$gene_cvg}))
names(cvg_list) <- genes
tx_list <- GRangesList(lapply(centered_genes, function(x) {x$gene_tx}))
names(tx_list) <- genes

```

```{r}
plot_multiple_genes(genes = genes,
                    centered_cvg = cvg_list,
                    centered_tx = tx_list)
```
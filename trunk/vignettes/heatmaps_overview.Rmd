---
title: "chipVis Heatmaps"
output: 
  html_document:
    toc: true
    toc_depth: 2
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Preparing Inputs

```{r libraries, message = FALSE, warning=FALSE, error=FALSE, cache = FALSE}
#require(gChipseq)
require(chipVis)
require(TxDb.Mmusculus.BioMart.igis)
require(plotly)
require(iHeatmapR)
BiocParallel::register(BiocParallel::MulticoreParam(4, progressbar = FALSE))
```

```{r inputs, message = FALSE, warning=FALSE, error=FALSE, cache = TRUE}

file.sample <- "/gne/research/workspace/schepa/BAP1_Data/BAP1_june_2016_samples.txt"
file.pair <- "/gne/research/workspace/schepa/BAP1_Data/BAP1_june_2016_pairs.txt"

samples <- read.table(file.sample,as.is=TRUE,header=TRUE)
samples_exp <- expandSampleTable(samples)

pairs <- read.table(file.pair,as.is=TRUE,header=TRUE)
pairs_exp <- expandPairedTable(pairs)

tss <- tssFromTxdb(txdb = TxDb.Mmusculus.BioMart.igis)
unique_tss <- unique(tss) #Remove same positions

peaks <- lapply( pairs_exp$File.macs, readMacsPeaks, fc=5, minTags=10, fdr=0.1)
peaks <- peaks[!sapply(peaks, is.null)]

merged_peaks <- reduce(do.call(c, peaks))

tss_in_peaks <- subsetByOverlaps(unique_tss, merged_peaks, maxgap = 1000)

bam_files <- samples_exp$File.bam
names(bam_files) <- samples$Genotype

cvg_files <- samples_exp$File.bw
names(cvg_files) <- samples$Genotype

mRNF2 <- grep("mRNF2", samples$Genotype)

cvg_mats <- make_coverage_matrix(inputs = bam_files[mRNF2],
                                  ranges = tss_in_peaks,
                                  binsize = 50,
                                  up = 2500,
                                  down = 2500)

scale_factors <- get_scaling_factor(file_info = samples_exp)

```

# Single coverage heatmap 

The single_coverage_heatmap function enables the creation of coverage heatmaps for a single sample.  The row_order option controls how the rows of the heatmap are ordered.  

### row_order = "none"

If row_order is set to "none", then the matrix is plotted in the order as provided.

```{r}
single_coverage_heatmap(cvg_mats[[1]], row_order = "none") 
```


### row_order = "hclust"

If row_order is set to "hclust", then hierarchical clustering is performed.

```{r}
single_coverage_heatmap(cvg_mats[[1]], row_order = "hclust")
```


#### custom distance function 

If desired, a custom distance function can be provided for use in heirarchical clustering.

```{r}
cor_dist <- function(x){
  as.dist(1 - cor(t(x)))
}

single_coverage_heatmap(cvg_mats[[1]], row_order = "hclust",  clust_dist = cor_dist) 
```


#### identifying k clusters from hierarchical clustering

The hierarchical clustering can be used to determine a set number of clusters by setting a value of k.  The tree will be cut at that number of clusters.

```{r}
single_coverage_heatmap(cvg_mats[[1]], row_order = "hclust", k = 3) 
```

### row_order = "kmeans"

If row_order is set to kmeans, kmeans clustering is performed on the rows. k must be specified.

```{r}
single_coverage_heatmap(cvg_mats[[1]], row_order = "kmeans", k = 3)
```

### row_order = "signal"

If row_order is set to signal, then rows are ordered based on the overall level of signal in each row.

## No summary

```{r}
single_coverage_heatmap(cvg_mats[[1]], row_order = "kmeans", k = 3, summary = FALSE) %>% plot_iHeatmap()
```


## Adding Annotations

If plotting coverage at peaks, it may be of interest what the distance of the peak to the nearest TSS is.  

```{r, warning = FALSE, message = FALSE}
peak_cvg_mats1 <- make_coverage_matrix(inputs = bam_files[mRNF2[1]],
                                  ranges = peaks[[mRNF2[1]]][1:1000],
                                  binsize = 50,
                                  up = 2500,
                                  down = 2500)

single_coverage_heatmap(peak_cvg_mats1, row_order = "signal", signal = rowSums(peak_cvg_mats1)) %>% 
  add_dist_to_tss(peaks[[mRNF2[1]]][1:1000],tss)

```

# Multiple coverage heatmaps 

```{r multi_coverage}
multi_coverage_heatmap(cvg_mats[1:3], row_order = "kmeans", k = 3)  
```

## Row ordering based on three heatmaps

By setting the "cluster_by" argument to "all" instead of the default of "first", all matrices are used for clustering -- they are concatenated horizontally prior to clustering.  

```{r multi_coverage2}
multi_coverage_heatmap(cvg_mats[1:3], row_order = "kmeans", k = 3, cluster_by = "all")  
```

# Aggregate profiles

To plot just the aggregate profile, the function aggregate_profile_plot can be used.

```{r aggregate_profile}
aggregate_profile_plot(cvg_mats)
```

If there isn't enough space for the legend, that can be adjusted using the "margin" attribute in plotly's layout function:

```{r}
aggregate_profile_plot(cvg_mats) %>% layout(margin = list(r = 200, b = 100))
```


# RNA Heatmap

```{r}

e <- readRDS("/gne/research/workspace/schepa/BAP1_Data/esetRPKM.RDS")

e <- e[which(substr(fData(e)$chr,1,3) == "chr"),]
fData(e)$chr <- sapply(fData(e)$chr, function(x) substr(x, 4, nchar(x)))
e <- e[which(fData(e)$chr %in% c(1:22,"X")),]

p1 = genomics_heatmap(log10(exprs(e)[1:500,] + 1), 
                     y = as.character(fData(e)$symbol[1:500]), 
                     x = as.character(pData(e)$TREATMENT_NAME), 
                     row_order = "kmeans", 
                     col_order = "hclust", 
                     row_k = 8, 
                     col_k = 4,
                    y_labels = NULL,
                    name = "RNA") 

as_plotly(p1) %>% layout(margin = list(b = 200))

```


# RNA + ChIP Aggregate

```{r}
promoter_ranges <- with(fData(e), GenomicRanges::GRanges(chr,
                                                         IRanges::IRanges(start,start),
                                                         strand = str,
                                                         symbol = symbol)) %>%
  GenomicRanges::promoters(upstream = 2500, downstream = 2500)


promoter_counts <- simplify2array(BiocParallel::bplapply(bam_files,
                                                         bamsignals::bamCount,
                                                         promoter_ranges[1:500]))
 
p1 %>% 
  add_genomics_heatmap(promoter_counts, col_order = "hclust", k_col = 4, scale_method = "normalize", name = "ChIP") %>%
  as_plotly()  %>% 
  layout(margin = list(b = 200))

```


# RNA + coverage heatmaps

```{r}
promoter_cvg_mats <- make_coverage_matrix(inputs = bam_files[mRNF2],
                                  ranges = promoter_ranges[1:500],
                                  binsize = 50)

p1 %>% add_coverage_heatmap(promoter_cvg_mats[[1]]) 

```

```{r}
p1 %>% add_coverage_heatmap(promoter_cvg_mats[[1]]) %>% add_coverage_heatmap(promoter_cvg_mats[[2]]) 

```









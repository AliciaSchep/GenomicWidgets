---
title: "Introduction"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(iheatmapr)
library(GenomicWidgets)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(GenomicRanges)
```

# Package goals

The GenomicWidgets package enables the creation of interactive visualizations for functional genomics data in R. These interactive visualizations can be included in stand-alone Rmarkdown HTML documents, or can be linked in shiny applications.  

# Genomics Heatmaps

The GenomicWidgets package builds on the iheatmapr package to enable creation of complex, interactive heatmaps for genomics data.  

## Expression heatmap

GenomicWidgets includes an `iheatmap` method for SummarizedExperiment objects, which are often used for storing expression data.  Compared to the `iheatmap` method for a matrix, the method for SummarizedExperiment has some different default settings that are often appropriate for expression or epigenomics data.  

The package includes a small subset of the expression data from the Roadmap Epigenomics project.  

```{r}
data("rpkm_chr21")
```

Here is what the `iheatmap` method applied to the matrix of RPKM values looks like:

```{r}
iheatmap(assays(rpkm_chr21)[["rpkm"]])
```

If instead we apply it to the SummarizedExperiment object, we see the result is different:

```{r}
iheatmap(rpkm_chr21,"rpkm")
```

For SummarizedExperiment, hierarchical clustering and standardization of rows is the default.  

We can further enhance this heatmap by passing along additional components of the SummarizedExperiment object to additional arguments to the `iheatmap` method.  

```{r}
iheatmap(rpkm_chr21, "rpkm",
         x = colData(rpkm_chr21)$STD_NAME, 
         y = rowData(rpkm_chr21)$SYMBOL, 
         col_annotation = colData(rpkm_chr21)[,c("TYPE","SEX")])
```

There is also an `add_iheatmap` method defined for SummarizedExperiment for adding a heatmap based on a SummarizedExperiment to an existing heatmap.

## Coverage heatmaps

GenomicWidgets also has methods for making coverage heatmaps.  

### The data

For demonstration of coverage heatmaps, we'll use ChIP-seq data for the H1 ESC cell line from the ENCODE project included in the genomationData Bioconductor package.  We'll first read in a sample table and get the correct paths to the files.  

```{r}
genomation_dir <- system.file("extdata", package = "genomationData")

samp.file <- file.path(genomation_dir,'SamplesInfo.txt')
samp.info <- read.table(samp.file, header=TRUE, sep='\t', 
                       stringsAsFactors = FALSE)
samp.info$fileName <- file.path(genomation_dir, samp.info$fileName)

```

Then we'll read in the location of CTCF peaks.  We'll plot the coverage at these peaks.

```{r}
ctcf.peaks = genomation::readBroadPeak(system.file("extdata",
                         "wgEncodeBroadHistoneH1hescCtcfStdPk.broadPeak.gz",
                         package = "genomationData"))
ctcf.peaks = ctcf.peaks[seqnames(ctcf.peaks) == "chr21"]
ctcf.peaks = ctcf.peaks[order(-ctcf.peaks$signalValue)]
ctcf.peaks = resize(ctcf.peaks, width = 501, fix = "center")
```

### Making coverage matrices

We first will make coverage matrices.  These will be returned as RangedSummarizedExperiment objects.  

```{r}
ctcf_mats <- make_coverage_matrix(samp.info$fileName[1:5], 
                                  ctcf.peaks, 
                                  input_names = samp.info$sampleName[1:5],
                                  up = 250, 
                                  down = 250, 
                                  binsize = 25)

```

You can also use your own preferred  method for making a coverage matrix.  The `coverage_heatmap` method shown below can accept either a SummarizedExperiment, a plain matrix, a list of matrices, or a ScoreMatrix or ScoreMatrixList object from the genomation package.  

### Single coverage

Here we will create a single coverage heatmap for the CTCF ChIP-seq.

```{r}
coverage_heatmap(ctcf_mats, "Ctcf")
```

### Adding coverage heatmap

```{r}
coverage_heatmap(ctcf_mats, "Ctcf") %>% add_coverage_heatmap(ctcf_mats, "Znf143")
```


### Multiple coverage heatmaps

```{r}
coverage_heatmap(ctcf_mats, c("Ctcf","Znf143"))
```

You can also add multiple coverage heatmaps at once to an existing heatmap using `add_coverage_heatmaps`. We will demonstrate that in the next section.

### Combining expression heatmap with coverage heatmap

Get coverage matrix at tss for the Chip-Seq

```{r}
tss <- promoters(rowRanges(rpkm_chr21), up = 1, down = 1)

tss_mats <- make_coverage_matrix(samp.info$fileName[1:5], 
                                  tss, 
                                  input_names = samp.info$sampleName[1:5],
                                  up = 500, 
                                  down = 500, 
                                  binsize = 25)
```

Make expression heatmap and then add coverage heatmap for TSS for two of the factors:

```{r}
iheatmap(rpkm_chr21, "rpkm",
         x = colData(rpkm_chr21)$STD_NAME, 
         y = rowData(rpkm_chr21)$SYMBOL, 
         col_annotation = colData(rpkm_chr21)[,c("TYPE","SEX")]) %>% 
  add_coverage_heatmap(tss_mats, c("P300","Suz12"))
```

# Interactive genome tracks

GenomicWidgets also has functions for interactive local views of genomic signals.  

## View ranges

## Pre-load annotation data

```{r Load Annotation reference}
tx_data <- unpack_transcripts(TxDb.Hsapiens.UCSC.hg19.knownGene)
```

## Track plotter

```{r}
track_plotter <- make_track_plotter(samp.info$fileName[1:3], 
                                    tx_data, 
                                    track_names = samp.info$sampleName[1:3] , 
                                    share_y = TRUE)
```

```{r}
track_plotter(ctcf.peaks[1])
```

## Multiple regions

```{r}
track_plotter(ctcf.peaks[1:3])
```

## Add in gene or locus level summaries


```{r}
summary_plotter <- make_summary_plotter(rpkm_chr21,
                                        groups = "GROUP")
```

```{r}
combined_plotter <- make_track_plus_summary_plotter(track_plotter, 
                                                    summary_plotter,
                                                    resize(tss, width = 5000, fix = "center"),
                                                    rownames(rpkm_chr21))
```

```{r}
combined_plotter(rownames(rpkm_chr21)[2:5])
```


# Apps linking heatmaps to genome tracks

Note: The following code has to be run interactively!

```{r, eval= FALSE}
hm <- iheatmap(rpkm_chr21, "rpkm",
         x = colData(rpkm_chr21)$STD_NAME, 
         y = rowData(rpkm_chr21)$SYMBOL, 
         col_annotation = colData(rpkm_chr21)[,c("TYPE","SEX")]) %>% 
  add_coverage_heatmap(tss_mats, c("P300","Suz12"))

link_fn <- heatmap_click(hm, rownames(rpkm_chr21))

heatmap_to_tracks_shiny(hm, combined_plotter, link_fn)

```

## To do

* Reverse strand for negative
* Easier Customization of y axis labels
* Easier customization of x axis labels




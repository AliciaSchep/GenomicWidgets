---
title: "Introduction"
author: "Alicia Schep"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(iheatmapr)
library(GenomicWidgets)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(GenomicRanges)
library(SummarizedExperiment)
```

# Package goals

The GenomicWidgets package enables the creation of interactive visualizations for functional genomics data in R. These interactive visualizations can be included in stand-alone Rmarkdown HTML documents, or can be linked in shiny applications. These visualization are intended to highlight the data at different scales, from a single locus to hundreds of regions along the genome, and to enable the views at different scales to be linked together.    

# Genomics Heatmaps

The GenomicWidgets package builds on the iheatmapr package to enable creation of complex, interactive heatmaps for genomics data.  

## Expression heatmap

GenomicWidgets includes an `iheatmap` method for SummarizedExperiment objects, which are often used for storing expression data.  Compared to the `iheatmap` method for a matrix, the method for SummarizedExperiment has some different default settings that are often appropriate for expression or epigenomics data.  

The package includes a small subset of the expression data from the Roadmap Epigenomics project.  

```{r}
data("rpkm_chr21")
```

Here is what the `iheatmap` method applied to the matrix of RPKM values looks like:

```{r}
iheatmap(assays(rpkm_chr21)[["rpkm"]])
```

If instead we apply it to the SummarizedExperiment object, we see the result is different:

```{r}
iheatmap(rpkm_chr21,"rpkm")
```

For SummarizedExperiment, hierarchical clustering and standardization of rows is the default.  

We can further enhance this heatmap by passing along additional components of the SummarizedExperiment object to additional arguments to the `iheatmap` method.  

```{r}
iheatmap(rpkm_chr21, "rpkm",
         x = colData(rpkm_chr21)$STD_NAME, 
         y = rowData(rpkm_chr21)$SYMBOL, 
         col_annotation = colData(rpkm_chr21)[,c("TYPE","SEX")])
```

There is also an `add_iheatmap` method defined for SummarizedExperiment for adding a heatmap based on a SummarizedExperiment to an existing heatmap.

## Coverage heatmaps

GenomicWidgets also has methods for making coverage heatmaps.  

### The data

For demonstration of coverage heatmaps, we'll use ChIP-seq data for the H1 ESC cell line from the ENCODE project included in the genomationData Bioconductor package.  We'll first read in a sample table and get the correct paths to the files.  

```{r}
genomation_dir <- system.file("extdata", package = "genomationData")

samp.file <- file.path(genomation_dir,'SamplesInfo.txt')
samp.info <- read.table(samp.file, header=TRUE, sep='\t', 
                       stringsAsFactors = FALSE)
samp.info$fileName <- file.path(genomation_dir, samp.info$fileName)

```

Then we'll read in the location of CTCF peaks.  We'll plot the coverage at these peaks.

```{r}
ctcf.peaks = genomation::readBroadPeak(system.file("extdata",
                         "wgEncodeBroadHistoneH1hescCtcfStdPk.broadPeak.gz",
                         package = "genomationData"))
ctcf.peaks = ctcf.peaks[seqnames(ctcf.peaks) == "chr21"]
ctcf.peaks = ctcf.peaks[order(-ctcf.peaks$signalValue)]
ctcf.peaks = resize(ctcf.peaks, width = 501, fix = "center")
```

### Making coverage matrices

We first will make coverage matrices.  These will be returned as RangedSummarizedExperiment objects.  

```{r}
ctcf_mats <- make_coverage_matrix(samp.info$fileName[1:5], 
                                  ctcf.peaks, 
                                  input_names = samp.info$sampleName[1:5],
                                  up = 250, 
                                  down = 250, 
                                  binsize = 25)

```

You can also use your own preferred  method for making a coverage matrix.  The `coverage_heatmap` method shown below can accept either a SummarizedExperiment, a plain matrix, a list of matrices, or a ScoreMatrix or ScoreMatrixList object (objects from the genomation package).  

### Single coverage

Here we will create a single coverage heatmap for the CTCF ChIP-seq.

```{r}
coverage_heatmap(ctcf_mats, "Ctcf")
```

### Adding coverage heatmap

```{r}
coverage_heatmap(ctcf_mats, "Ctcf") %>% add_coverage_heatmap(ctcf_mats, "Znf143")
```


### Multiple coverage heatmaps

```{r}
coverage_heatmap(ctcf_mats, c("Ctcf","Znf143"))
```

You can also add multiple coverage heatmaps at once to an existing heatmap using `add_coverage_heatmaps`. We will demonstrate that in the next section.

### Combining expression heatmap with coverage heatmap

Get coverage matrix at tss for the Chip-Seq

```{r}
tss <- promoters(rowRanges(rpkm_chr21), up = 1, down = 1)

tss_mats <- make_coverage_matrix(samp.info$fileName[1:5], 
                                  tss, 
                                  input_names = samp.info$sampleName[1:5],
                                  up = 500, 
                                  down = 500, 
                                  binsize = 25)
```

Make expression heatmap and then add coverage heatmap for TSS for two of the factors:

```{r}
iheatmap(rpkm_chr21, "rpkm",
         x = colData(rpkm_chr21)$STD_NAME, 
         y = rowData(rpkm_chr21)$SYMBOL, 
         col_annotation = colData(rpkm_chr21)[,c("TYPE","SEX")]) %>% 
  add_coverage_heatmap(tss_mats, c("P300","Suz12"))
```

# Interactive genome tracks

GenomicWidgets also has functions for interactive local views of genomic signals.  

## Track plotter

```{r}
track_plotter <- make_track_plotter(samp.info$fileName[1:3], 
                                    annotation = TxDb.Hsapiens.UCSC.hg19.knownGene, 
                                    track_names = samp.info$sampleName[1:3] , 
                                    share_y = TRUE)
```

```{r}
track_plotter(resize(ctcf.peaks[1], width = 10000, fix = "center"))
```

## Multiple regions

```{r}
track_plotter(resize(ctcf.peaks[1:5], width = 10000, fix = "center"))
```

## Add in gene or locus level summaries

We can add a boxplot next to each region summarizing the gene expression levels (or any other feature of the locus) for some group of samples.  We do that by first creating a function to generate such a summary based on a SummarizedExperiment object.  We pass along to the `group` argument the name of a column in the colData of the SummarizedExperiment object that we will use to group the expression values along the x axis.  

```{r}
summary_plotter <- make_summary_plotter(rpkm_chr21,
                                        groups = "GROUP")
```

We use the function `make_track_plus_summary_plotter` to link our track plotter and our summary plotter.  We give both of the plot generators, as well as the ranges that correspond to all the rows of the expression data and the rownames of the expression data.  

```{r}
combined_plotter <- make_track_plus_summary_plotter(track_plotter, 
                                                    summary_plotter,
                                                    resize(tss, width = 5000, fix = "center"),
                                                    rownames(rpkm_chr21))
```

Calling our combined plotter function with some rownames of the expression data creates a plot of the ChIP-seq signal around the TSS of those genes as well as a boxplot of the gene expression for different samples for that gene on the right.  

```{r}
combined_plotter(rownames(rpkm_chr21)[1:3])
```


# Apps linking heatmaps to genome tracks

We can link our heatmap views of many genes/regions with the more detailed track views by making a shiny app that links the two through a click event.  We will need both our heatmap object, a track generator function, and a link function that helps link the heatmap to the track view.  The link function takes as input the heatmap as well as the potential input for the track function.  That input should be ordered according to how the rows were ordered in the input data for the heatmap.  

Note: The following code has to be run interactively!

```{r, eval= FALSE}
hm <- iheatmap(rpkm_chr21, "rpkm",
         x = colData(rpkm_chr21)$STD_NAME, 
         y = rowData(rpkm_chr21)$SYMBOL, 
         col_annotation = colData(rpkm_chr21)[,c("TYPE","SEX")]) %>% 
  add_coverage_heatmap(tss_mats, c("P300","Suz12"))

link_fn <- heatmap_click(hm, rownames(rpkm_chr21))

heatmap_to_tracks_shiny(hm, combined_plotter, link_fn)

```

## To do

* Reverse plot for negative strand
* Easier Customization of y axis labels
* Easier customization of x axis labels
* add description of grouping options, fine-tune
* check color handling




---
title: "Feature Extraction"
author: "Justin Finkle"
date: "8/17/2016"
output: html_document
---
# **Note to user**
This is very preliminary code to give a sense of how machine learning can be used
to reduce dimensions, and infer regulatory regions that govern gene expression. If the ideas intrigue you, this code could easily be adapted into an analysis pipeline 
```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo = FALSE, cache = TRUE)
library(chipVis)
library(TxDb.Hsapiens.BioMart.igis3.0)
library(org.Hs.eg.db)
library(dplyr)
library(plotly)
library(iheatmapr)
```

```{r Match transcripts with symbol, echo = FALSE}
tr <- transcriptsBy(TxDb.Hsapiens.BioMart.igis, by = "gene") %>% unlist()
tr$entrez <- stringr::str_extract(names(tr),"(?<=:)(.*)")
tr$symbol <- annotate::getSYMBOL(tr$entrez, data='org.Hs.eg')
names(tr) = NULL
trdf <- as.data.frame(tr)

truniq <- trdf %>% group_by(entrez) %>% dplyr::summarize(chr = first(seqnames),
                                                  start = min(start),
                                                  end = max(end),
                                                  strand = first(strand),
                                                  symbol = first(symbol))
```

```{r Load Data}
fi <- readRDS("/gne/research/workspace/schepa/Carroll_Data/chip_file_info.Rds")

org <- "human"
genome <- "GRCh38"

# Get scaling factors based on library size
sf <- get_scaling_factor(fi)[2,]/1000000

T47D = list(
  ER_ab = which(fi$source_name == "T47D_ER_Full_Media_3hr"),
  ER_ab_Pr_treat = which(fi$source_name == "T47D_ER_Progesterone_3hr"),
  ER_ab_R5020_treat = which(fi$source_name == "T47D_ER_R5020_3hr"),
  
  PR_ab  = which(fi$source_name == "T47D_PR_Full_Media_3hr"),
  PR_ab_Pr_treat = which(fi$source_name == "T47D_PR_Progesterone_3hr"),
  PR_ab_R5020_treat = which(fi$source_name == "T47D_PR_R5020_3hr"),
  
  p300_ab  = which(fi$source_name == "T47D_p300_Full_Media_3hr"),
  p300_ab_Pr_treat  = which(fi$source_name == "T47D_p300_Progesterone_3hr"),
  p300_ab_R5020_treat = which(fi$source_name == "T47D_p300_R5020_3hr")
  
)
```

```{r Read in peaks}
peaks <- read_macs_peaks(T47D, fi)
```

# Example Log plot for 1 gene
```{r}
symbol <- "GREB1"
sym_idx <- which(truniq$symbol == symbol)
symbol_range <-get_view_range(chr = truniq$chr[sym_idx],
                              start = truniq$start[sym_idx],
                              end = truniq$end[sym_idx],
                              strand = as.character(truniq$strand[sym_idx]))
```

```{r}
n_recurse_tiles <- 10
pseudo_tss <- ifelse(strand(symbol_range)=="-", 
                     end(symbol_range), 
                     start(symbol_range))
scaled_range <- log_scale_range(center = pseudo_tss, 
                                chromosome = seqnames(symbol_range),
                                n = n_recurse_tiles, 
                                min_bin = 100)
```

# Log-Scale for NRIP1
The log scale gives us a good dynamic range for seeing peaks. The plot shows the 
average peak height per bin. Peaks don't really show up until 100kb from the TSS
```{r, eval=TRUE, include=TRUE}
log_peaks <- peaks_per_sample(peak_list = peaks, gr = scaled_range)
all_peaks <- log_peaks
# mcols(all_peaks) <- Reduce(cbind, log_peaks)
df <- biovizBase::mold(all_peaks)
hm_vals <- apply(t(as.matrix(as.data.frame(mcols(all_peaks)))), 2, rev)+1
# hm_vals <- matrix(rnorm(length(hm_vals)), nrow=nrow(hm_vals))
p <- plot_ly(z=hm_vals, y=rownames(hm_vals),type='heatmap', colorscale = continuous_colorscale("Purples")(hm_vals),
               hoverinfo='x+z')
lines <- make_lines(symbol_range = symbol_range, scaled_range = scaled_range, hm_vals = hm_vals, base = n_recurse_tiles)
p %>% layout(shapes=lines$lines,
             xaxis=list(tickvals = lines$vals, ticktext = names(lines$vals), tickmode='array',
                        zeroline=FALSE, showline=TRUE, mirror=TRUE),
             margin = list(l=150))
```

# Linear Scale
The plot below shows the same range for peaks, but on a linear scale. Bins are 
around 27kb long. This makes it look like peaks are right next to the TSS, which
is not the case
```{r Large Scale, eval=TRUE, include=TRUE}
tiled_range <- tile(reduce(scaled_range), n = length(scaled_range))[[1]]
all_peaks <- peaks_per_sample(peak_list = peaks, gr = tiled_range)
# all_peaks <- tiled_range
# mcols(all_peaks) <- Reduce(cbind, even_peaks)
df <- biovizBase::mold(all_peaks)
hm_vals <- apply(t(as.matrix(as.data.frame(mcols(all_peaks)))), 2, rev)+1
# hm_vals <- matrix(rnorm(length(hm_vals)), nrow=nrow(hm_vals))
n_bins <- length(tiled_range)
x_vals <- c(-rev(cumsum(width(tiled_range)[1:(n_bins/2)])), cumsum(width(tiled_range)[(n_bins/2+1):n_bins]))
p <- plot_ly(z=hm_vals, y=rownames(hm_vals),type='heatmap', colorscale = continuous_colorscale("Purples")(hm_vals),
               hoverinfo='x+z', x = x_vals)
# lines <- make_lines(symbol_range = symbol_range, scaled_range = tiled_range, hm_vals = hm_vals, base = n_recurse_tiles)
p %>% layout(xaxis=list(zeroline=FALSE, showline=TRUE, mirror=TRUE),
             margin = list(l=150))
```

# Linear Scale, small bins
Here we also use a linear scale, but with smaller bins of 1kb. We no longer have
the issue of thinking peaks are close to the TSS, however visually it is hard to
see much signal. If you zoom to +100kb, you'll see that there are indeed strong
peaks. Overall though, the heatmap is very sparse, and it it isn't clear where
the user should zoom to see the strong peaks. 
```{r 1000bp bins, eval=TRUE, include=TRUE}
tiled_range <- tile(reduce(scaled_range), width = 1000)[[1]]
all_peaks <- peaks_per_sample(peak_list = peaks, gr = tiled_range)
# all_peaks <- tiled_range
# mcols(all_peaks) <- Reduce(cbind, even_peaks)
df <- biovizBase::mold(all_peaks)
hm_vals <- apply(t(as.matrix(as.data.frame(mcols(all_peaks)))), 2, rev)+1
# hm_vals <- matrix(rnorm(length(hm_vals)), nrow=nrow(hm_vals))
n_bins <- length(tiled_range)
x_vals <- c(-rev(cumsum(width(tiled_range)[1:(n_bins/2)])), 
            cumsum(width(tiled_range)[(n_bins/2+1):n_bins]))
p <- plot_ly(z=hm_vals, y=rownames(hm_vals),type='heatmap', colorscale = continuous_colorscale("Purples")(hm_vals),
               hoverinfo='x+z', x = x_vals)
# lines <- make_lines(symbol_range = symbol_range, scaled_range = tiled_range, hm_vals = hm_vals, base = n_recurse_tiles)
p %>% layout(xaxis=list(zeroline=FALSE, showline=TRUE, mirror=TRUE),
             margin = list(l=150))
```


# Prep expression data
```{r Get Significant expression}
rpkmEset <- readRDS("/gne/research/workspace/schepa/Carroll_Data/GSE68358.rpkmEset.with_fdata.Rds")
T47D_eset <- rpkmEset[,grep("T47D",pData(rpkmEset)$celltype)]
treat_groups = stringr::str_trim(sapply(stringr::str_split(pData(T47D_eset)$treatment,":"), 
                      function(x) x[[2]])) %>% gsub("+","_",., fixed= TRUE) %>% 
  gsub("_3hr","",.)

library(limma)
library(edgeR)

dge <- DGEList(counts = exprs(T47D_eset)) %>% calcNormFactors()
design <- model.matrix(~ 0 +treat_groups)
colnames(design) = gsub("treat_groups", "", colnames(design))
v <- voom(dge, design=design)

fit <- lmFit(v, design)
contrasts <- makeContrasts(E2_Progesterone-E2, 
                           E2_R5020-E2, 
                           E2_R5020-E2_Progesterone, levels = design)
fit2 <- contrasts.fit(fit, contrasts) %>% eBayes()
results_Progesterone <- topTable(fit2, coef = 1, adjust = "BH")
results_R5020 <- topTable(fit2, coef = 2, adjust = "BH")

results <- decideTests(fit2, p.value = 0.01, lfc = 1)
sig <- which(apply(results,1, function(x) sum(x!=0) > 0))
sig_genes <- fData(T47D_eset)$symbol[sig]
```

# Learning
**Note** By default this code will not run. It uses basic parallelization, but can
still take a while to run.

A matrix of the coefficients is saved to avoid rerunning this section.
```{r eval=FALSE}
library(glmnet)
library(BiocParallel)
# For each significant gene
n_recurse_tiles <- 10
min_bin <- 100
conditions <- c("E2", "P4", "R5020")
set.seed(8)
c_list <- mclapply(X = sig,
                   FUN = learning,
                         T47D_eset,
                         truniq,
                         peaks, mc.cores=4)
all_coefs <- matrix(unlist(c_list), nrow=length(c_list), byrow = T)
rownames(all_coefs) <- sig_genes
scale <- cumsum(sort(width(scaled_range)[1:37]))
colnames(all_coefs) <- c(-rev(scale), scale)
```

# Positional importance
This plot shows the coefficients for each gene along the log-scaled positions. How
the rows should be clustered is unknown, but there is clearly some structure. 
```{r}
# Load precomputed coefficients
all_coefs <- readRDS("~/workspace/test_coeffs.Rds")
col_group_names <- gsub(pattern = "Progesterone", replacement = "P4", treat_groups)
coef_hm <- simple_heatmap(mat = all_coefs, 
                          row_order = "kmeans",
                          row_k = 8,
                          col_groups = width(scaled_range),
                          colorscale = diverging_colorscale())
coef_hm %>% add_genomics_heatmap(v$E[sig,], 
                           col_groups = col_group_names, 
                           x = pData(T47D_eset)$title, 
                           colorscale = diverging_colorscale(c(scales::muted("blue"),
                                                               "white", scales::muted("red")))) 


```


```{r}
# For one sample get the the peaks on log-scale for all significant genes
n_genes <- 100
peak_list <- sapply(X = sig[1:n_genes], function(x) {
  symbol_range <-get_view_range(chr = truniq$chr[x],
                              start = truniq$start[x],
                              end = truniq$end[x],
                              strand = as.character(truniq$strand[x]))
  n_recurse_tiles <- 10
  pseudo_tss <- ifelse(strand(symbol_range)=="-", 
                     end(symbol_range), 
                     start(symbol_range))
  scaled_range <- log_scale_range(center = pseudo_tss, 
                                chromosome = seqnames(symbol_range),
                                n = n_recurse_tiles, 
                                min_bin = 100)
  log_peaks <- peaks_per_sample(peak_list = peaks[1], gr = scaled_range)
  as.matrix(mcols(log_peaks))
})
gene_peaks <- matrix(unlist(peak_list), nrow=n_genes, byrow = T)
rownames(gene_peaks) <- truniq$symbol[1:n_genes]
```

```{r}
hm <- genomics_heatmap(gene_peaks, 
                       col_groups = width(scaled_range),
                       col_order = 'none',
                       row_order = "hclust")
hm %>% add_genomics_heatmap(all_coefs[1:n_genes,],
                            col_groups = width(scaled_range),
                            col_order = "none")

```